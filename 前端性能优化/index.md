# 前端性能优化

<!--more-->
>前端性能优化

### 纵观http请求的过程，可以得出一些请求过程中的潜在的性能优化
* dns是否可以通过缓存减少dns查询的时间?
* 网络请求的过程走最近的网络环境？
* 相同的静态资源是否可以缓存？
* 能否减少请求http请求大小？
* 减少http请求
* 服务端渲染


### 资源的合并与压缩
* 减少http请求的数量
* 减少请求资源的大小
<!--more-->
>
### html 压缩
* webpack打包压缩
* nodejs 提供了html-minifier工具
* 后端模板引擎渲染压缩
  
### css 压缩
* clean-css库
* 无效代码删除
* css语义合并-有些属性重复
### js 压缩与混乱
---uglifyjs2
* 无效字符的删除
* 剔除注释
* 代码语义的缩减和优化
* 代码保护-降低代码的可读性


### 文件合并
 存在的问题:1、首屏渲染问题 2、缓存失效问题
 * 公共库合并
 * 不同页面的合并
 * 开启gzip


### 图片优化
#### 一、不同格式图片常用的业务场景
* jpg有损压缩，压缩率高，不支持透明——应用与大部分不需要透明图片的业务场景
* png支持透明，浏览器兼容性好——应用于大部分需要透明图片的业务场景
* webp压缩程度更好，在ios webview有兼容性问题——安卓
* svg矢量图，拉伸不失真，代码内嵌,相对较小,图片样式相对简单的场景——图片样式相对简单的业务场景，icon,logo
#### 二、[图片压缩](https://tinypng.com/)——针对真实图片情况，舍弃一些相对无关紧要的色彩信息
* CSS精灵图
  把网站上用到的一些图片整合到一张单独的图片中(减少网站的HTTP请求数量)，利用CSS背景属性进行调整，需要控制精灵图的大小，过大可能会导致加载过慢，整个页面内容显示不正常。
* Image inline
  将图片的内容内嵌到html当中,减少网站HTTP请求数量
* 使用矢量图
  使用SVG进行矢量图的绘制
  使用iconfont解决icon问题    


### HTML渲染过程
#### 一、需要考虑的点
* 顺序执行、并发执行
  词法分析
  并发加载
  并发上限
* 是否阻塞
  1)CSS阻塞
  css head中阻塞页面的渲染
  css阻塞js的执行
  css不阻塞外部脚本的加载，外部的脚本是基于已经加载完的css样式去操作dom
  2)js阻塞
  直接引入(srcipt src='js')会导致阻塞页面的渲染
  js不阻塞资源的加载，会预先扫描，预加载
  js顺序执行，会阻塞后续js逻辑的执行(单线程)
* 依赖关系
  1)页面渲染依赖于css的加载
  2)js的执行顺序的依赖关系
  3)js逻辑对于dom节点的依赖关系
* js引入方式
  直接引入
  defer引入
  async
  异步动态引入js

#### 二、加载和执行的一些优化点
* css样式表置顶
* 用link 代替 import
* js 脚本置底
* 合理使用js的异步加载能力
### 懒加载与预加载
#### 一、[懒加载](https://github.com/hilongjw/vue-lazyload)
* 图片进入可视区域之后请求图片资源
* 对于电商等图片很多，页面很长的业务场景使用
* 减少无效资源的加载
* 并发加载的资源过多会阻塞js的加载，影响网站的正常使用
#### 二、预加载
* 图片等静态资源在使用之前的提前请求
* 资源使用到时能从缓存中加载，提升用户体验
* 页面展示的依赖关系维护


### 重绘与回流
* 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢
  解决办法：
  1)寻找替代会引起重绘回流的方案(避免使用触发重绘，回流的CSS属性)
  2)如无法避免，将频繁重绘回流的DOM元素单独作为一个独立图层，一次插入到布局中，那么这个dom元素的重绘回流只会影响一次，而且在独立图层里
  
#### 一、回流
* 当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建——回流
* 当页面布局和几何属性改变时就需要回流
  1)触发的条件
  * 盒子模型相关属性——width、height、padding、margin、display、border
  * 定位属性及浮动——top、bottom、left、right、position、float、clear
  * 改变节点内部文字结构——
  text-align
overflow-y
font-weight
overflow
font-family
line-height
vertical-align
white-space
font-size、
#### 二、重绘
* 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color——重绘

#### 三、新建DOM的过程
* 获取DOM后分割为多个图层
* 对每个图层的节点计算样式结果(Recalculate style 样式重计算)
* 为每个节点生成图形和位置(Layout 回流和重布局)
* 将每个节点绘制填充到图层位图中(Paint Setup和Paint 重绘)
* 图层作为纹理上传至gpu
* 符合多个图层到页面上生成最终屏幕图像(Composite Layers 图层重组)
#### 四、浏览器绘制DOM的过程是这样子的：
* 获取 DOM 并将其分割为多个层（layer），将每个层独立地绘制进位图（bitmap）中
* 将层作为纹理（texture）上传至 GPU，复合（composite）多个层来生成最终的屏幕图像
* left/top/margin之类的属性会影响到元素在文档中的布局，当对布局（layout）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。
* transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。
* 通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。
#### 五、chrome创建图层的条件
——将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中
* 3D或透视变换
* CSS属性使用加速视频解码的 video 元素
* 拥有 3D (WebGL) 上下文或加速的
* 2D 上下文的 canvas 元素
* 复合插件(如 Flash)
* 进行 opacity/transform 动画的元素拥有加速
* CSS filters 的元素元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
* 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)
总结：对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧

#### 六、优化点总结
* 用translate替代top属性
top会触发layout，但translate不会
* 用opacity代替visibility
   * opacity不会触发重绘也不会触发回流，只是改变图层alpha值，但是必须要将这个图片独立出一个图层
   * visibility会触发重绘
* 不要一条一条的修改DOM的样式，预先定义好class，然后修改DOM的className
* 把DOM离线后修改，比如：先把DOM给display:none（有一次reflow），然后你修改100次，然后再把它显示出来
* 不要把DOM节点的属性值放在一个循环里当成循环的变量
   * offsetHeight、offsetWidth每次都要刷新缓冲区，缓冲机制被破坏
   * 先用变量存储下来
* 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局，div只会影响后续样式的布局
* 动画实现的速度的选择，选择合适的动画速度
* 根据performance量化性能优化
* 对于动画新建图层
   * 启用gpu硬件加速(并行运算)，gpu加速意味着数据需要从cpu走总线到gpu传输，需要考虑传输损耗.
   * transform:translateZ(0)
   * transform:translate3D(0)

### 浏览器存储
#### 一、cookie
* 用于浏览器端和服务器端的交互(主要作用，维护用户状态)
* 客户端自身数据的存储(在localstorage诞生前的主要手段)
* cookie中在相关域名下面导致cdn的流量损耗——解决方案：cdn的域名和主站域名要分开

#### 二、LocalStorage
* HTML5设计出来专门用于浏览器存储的
* 大小为5M左右
* 仅在客户端使用，不和服务端进行通信
* 接口封装较好
* 浏览器本地缓存方案

#### 三、SessionStorage
* 会话级别的浏览器存储(和localstorage唯一的区别)
* 场景： 对于表单信息的维护

#### 四、[indexedDB](https://www.cnblogs.com/1285026182YUAN/p/15305466.html)
* IndexedDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然WebStorage对于存储叫少量的数据很管用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。
* 场景：为应用创建离线版本

#### 五、PWA
* PWA(Progressive Web Apps)是一种Web App新模型，并不是具体指某一种前言的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强Web App的用户体验
   * 检测是不是一个渐进式 web app
     1)当前手机在弱网环境下能不能加载出来
     2)离线环境下能不能加载出来
   * 特点
1)可靠：没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面
2)快速：针对网页渲染及网络数据访问有较好的优化
3)融入(Engaging)：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性

#### 六、[service worker](https://mp.weixin.qq.com/s/3Ep5pJULvP7WHJvVJNDV-g)
* 是一个脚本，浏览器独立于当前页面，将其在后台运行，为实现一些不依赖页面的或者用户交互的特性打开了一扇大门。在未来这些特性将包括消息推送，背景后台同步， geofencing(地理围栏定位)，但他将推出的第一个首要的特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。


### 浏览器缓存

#### 
