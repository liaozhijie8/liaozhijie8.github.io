# 原型

<!--more-->
### 关于原型

#### 1.为什么要用原型 【好处】
原型上所有的方法和属性都可以被构造函数【实际开发原型主要共享方法和所有实例公用引用属性】的实例共享。

***举个例子***
QQUsers是一个构造函数，所有实例化的对象上面都会有一个共有的方法show以及属性commonfriends。
```
function QQUsers (QQNo_, QQAge_, QQMark_) {
  this.QQNo = QQNo_;//QQ号
  this.QQAge = QQAge_;//Q龄
  this.QQMark = QQMark_;//QQ标签
  //引用对象类型=引用类型=对象类型=引用数据类型 
  // 数组也是一种引用数据类型 
  this.commonfriends = ['骑驴看海', '大漠上的英雄', '坚实的果子', '小草']//共同好友
  // 方法也是一种引用数据类型 
  this.show = function () {
    console.log(`QQ号:${this.QQNo},QQ龄:${this.QQAge},QQ标注:${this.QQMark}`)
    console.log(`共同的好友是:${this.commonfriends}`);
  }
}
// 对象也叫实例(instance)
// QQZhangSan叫做对象变量 对象是等号右边通过new出来的一个实例 而且是运行期间才在堆中开辟对象的内存空间
let QQZhangSan = new QQUsers("37834522", 15, "王阳明传人")
let QQLisi = new QQUsers("30424232", 10, "袁隆平的徒弟")
//let QQLiuwu = new QQUsers("刘武", 12, "飞起来的鸭子")

QQZhangSan.show();
QQLisi.show();
//QQLiuwu.show();


```
#### 2.没有用原型会有什么问题?
所有 QQUser 对象【也叫 QQUser 实例】都有相同的好友属性，好友属性用 commonfriends 英文表示，所有 QQUser 对象都有相同的 show 方法。但我们发现每一个 QQUser对象 【也叫 QQUser 实例】都单独分配一个 commonfriends 属性空间和 show 方法空间，浪费了大量内存空间

答案：使用原型解决

### 理解原型

#### 1.认识函数+原型定义

* ​函数也是一个对象，当真正开始执行函数，执行环境【开发时为浏览器或控制台】会为函数分配一个函数对象变量空间和函数对象空间，函数对象变量用函数名表示，存在栈空间中， 函数对象空间是在堆中开辟的一个内存空间，这个空间中有一个默认的 prototype 属性，这个 prototype 属性就是一个原型对象属性【也叫对象变量】  

* 函数和构造函数的区别  
当通过 new 函数()时，此刻这个函数就是构造函数【 日后会演变成TS 类的构造器】 
* 定义：原型【 prototype ] 是定义函数由 JS 自动分配给函数的一个可以被所有构造函数实例对象变量共享的对象变量【也叫对象属性】

#### 2. 如何访问原型对象空间上的属性和方法
* 构造函数所有实例对象都可以访问型对象空间上的属性和方法 [每一个实例都有默认的 `__proto__` 属性，这个 `__proto__` 属性指向原型对象空间]

* 关于__proto____：new 在创建新对象的时候，会赋予新对象一个属性指向构造函数的 `prototype` 对象空间，这个属性就是  `__proto__`

* 可以直接通过构造函数.prototype 对象属性来访问原型对象空间上的属性和方法

#### 3.1 构造函数实例【也叫对象】如何访问原型对象空间上的属性和方法
* 构造函数实例访问一个属性和方法，首先从实例空间中查找【当执行环境执行 new 构造函数()时，构造函数中通过 this 定义的属性和方法会分配在这个空间中】，如果找到该属性和方法，就停止查找，表示找到了；如果没有找到，就继续在该实例的原型对象空间中去查找该属性和方法 【实例中默认的  `__proto__` 对象 属性指向原型对象空间】
* 实例正是借助自身的__ proto __对象属性 来查找原型对象空间中的属性和方法，有点像儿子去和爸爸要他没有的东西一样。】 

#### 3.2  增加或修改原型对象的属性或方法后， 所有的实例或叫对象立即可以访问的到 【但创建实例后再覆盖原型除外】

​

####  6.Object.prototype


​	

#### 7.原型链+常见的五种原型继承


​	

####  8.call/apply/bind方法


​	

#### 9.new 构造函数底层到底发生了什么 【深入new底层到底发生了什么】


​	


​	



