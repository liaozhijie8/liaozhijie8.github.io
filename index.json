[{"categories":["Vue"],"content":"vue各版本的API别 ","date":"2022-07-18","objectID":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/:0:0","tags":["API","vue"],"title":"Vue不同版本API","uri":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/"},{"categories":["Vue"],"content":"Vuex is a state management pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":" State Management Pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"为什么需要状态管理？ 在回答这个问题之前我们先看一下不用Vuex,是如何进行组件之间的数据传递的 以Vue2为例子，组件之间的数据共享大致分为三部分 类型 方式 父组件-\u003e子组件 子组件中,通过 props 来自定义属性 父组件中,负责把数据，通过 v-bind: 绑定给子组件 子组件-\u003e父组件 子组件中调用 this.$emit() 来触发自定义事件. 父组件中，通过 v-on: 来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件传递过来的数据。. 兄弟组件共享数据 EventBus 其实原理与子组件传父组件相似 显然这种方式对于单个数据或者少量数据处理是没有问题的，但是官方提出了两个问题 Multiple views may depend on the same piece of state. Actions from different views may need to mutate the same piece of state. 当我们需要多组件共享数据或者处理数据时，会变得繁琐，尤其是当嵌套组件过多时，单向数据的传递会变得尤为复杂且低效 为解决这两个问题,需要一个全局管理数据的工具—–Vuex Vuex工作流程 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:1","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"如何使用Vuex 组成部分 组成 作用 State 存放全局数据 Getters 简单计算处理State中的数据,再传递给组件 Mutations 通过commit方法改变State中的数据,执行的是同步操作 Actions 通过dispatch方法调用Mutations中的方法改变State中的数据,执行的是异步操作 Modules 模块化 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:2","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"使用步骤 利用createStore方法新建实例 import { createStore } from 'vuex' import index from './cart/index' const store = createStore({ modules: { cart: index //子模块 } }) export default store 在main函数中注册 import { createApp } from 'vue' import App from './App.vue' import store from './store' //引入注册 const app = createApp(App) app.use(store) app.mount('#app') 子模块定义数据方法 import { Goods } from './interface' export default { // 开启空间命名 namespaced: true, state: { goods: [ { id: 0, name: '牙刷', price: 20, count: 22 }, { id: 1, name: '平板', price: 2, count: 322 }, { id: 2, name: '背包', price: 210, count: 266 }, { id: 3, name: '电脑', price: 203, count: 255 }, { id: 4, name: '手机', price: 204, count: 23 } ], totalPrice: 0 }, getters: { getPrice: (state: Goods) =\u003e (price: number) =\u003e { return state.goods.filter(d =\u003e d.price \u003e price) } }, mutations: { addPrice(state: Goods, id: number) { state.totalPrice += state.goods[id].price } }, actions: { fetchTotalPrice({ commit }, payload: number) { commit('addPrice', payload) } } } 在组件中使用 需要注意引用子模块的方式 import { useStore } from 'vuex' setup() { const store = useStore() // 引用方法store.属性.模块名称.数据 const goods = computed(() =\u003e store.state.cart.goods) const totalPrice = computed(() =\u003e store.state.cart.totalPrice) const chooseGoods = (id: number) =\u003e { // 使用action store.dispatch('cart/fetchTotalPrice', id) } // // // 使用getter const priceGoods = computed(() =\u003e store.getters['cart/getPrice'](100)) return { goods, priceGoods, totalPrice, chooseGoods } } }) ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:3","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"全新的版本pinia Why should I use Pinia? ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:4","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"关于 王者荣耀全能烹饪师 ","date":"2022-07-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["书签整理"],"content":"学习书签集合","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["书签整理"],"content":" JavaScript学习书签 各种对象方法 JavaScript 中 call()、apply()、bind() 的用法 ES6 教程 CSS学习书签 Flex 布局语法教程 ","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/:0:0","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["CSS"],"content":"一次解决所有居中烦恼","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"水平居中 根据元素的类型不同可以分为两类情况 一类使行内元素，它不能设置宽高，所以需要给其父元素设置一个text-align: center; 一类使块级元素，其可以设置宽高， 在自身已经设置宽高具体参数的情况下，可以给margin：0 auto 利用position属性，相对父元素，移动左边或右边50%，然后再设置margin调整位置 See the Pen 各种水平居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:1","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"垂直居中 See the Pen 垂直居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:2","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"flex就是好用","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":" Flex 布局语法教程 ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:0","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"flex实现双飞布局 父元素设置flex，项目元素设置比例即可实现布局 See the Pen flex布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:1","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"画颗骰子 设置项目元素自身属性align-self调节垂直方向位置 See the Pen flex布局骰子 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:2","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"float布局页面","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":" 经典的双飞翼与圣杯布局，主要利用了CSS盒子模型的特性，以float布局为主要方法，结合Position属性。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:0","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"前置知识了解 CSS盒子模型 我们需要先了解CSS的盒子模型，详细的参考标题链接内容，关键点在于当我们指定一个CSS元素的宽度和高度属性时，只是设置内容区域的宽度和高度，要知道，完整大小的元素，还必须添加内边距，边框和外边距。 当然我们也可以添加一个属性设置整个盒子的总宽度和高度 /* 加上这个css3的新特性，可以自动计算，保持总的宽高是设置的值 */ box-sizing: border-box; 负值的margin带来的影响 一般来说，我们都是给一个元素设置margin正值来调整与其他元素的距离，如果我们给margin设置负值会发生什么呢？ 我们分两种情况讨论： 水平方向 1、margin-left设置负值，会使自身以及后面的元素一起往左移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的宽度content的百分比) 2、margin-right设置负值，自身不发生改变，但会令后面的元素往左移动，移动的距离原理同上。 垂直方向 1、margin-top设置负值，会使自身以及后面的元素一起往上移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的高度content的百分比) 2、margin-bottom设置负值，自身不发生改变，但会令后面的元素往上移动，移动的距离原理同上。 ————————-可以在下方CSS指定位置中测试 See the Pen 负值的margin带来的影响 by liaozhijie8 (@liaozhijie8) on CodePen. CSS Float(浮动) 在网页流中，所有元素都是一个盒子，类似于玩俄罗斯方块一样，如果一行宽度不够放下一个完整的积木，那么这块积木将会放到下一行，慢慢地充满整个网页。这是一个二维的平面，如果转变为三维模型，把每一个元素再加上一个厚度。假设在排列过程中每一块元素的厚度一致，一行排不下同样需要换行，但是有些元素我们还是希望他们在这一行排列，那么就把他们排列在第二层中，这就是CSS float特性，具体参考标题链接。 CSS Position(定位) 有时候我们希望元素能按照给定的坐标定位，例如坐标(x,y),那么我们只需设置一个参考的原点即可，那就是position属性，详情点击链接。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:1","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"双飞翼布局 原理 双飞翼布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。 双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间middle多了一个子容器存在，通过控制 middle 的子容器的 margin或者padding空出左右两列的宽度。 See the Pen 双飞布局 by liaozhijie8 (@liaozhijie8) on CodePen. 1、左中右三列都设置float左浮动 2、中间列设置100%的宽度(达到自适应剩余宽度的效果)，并包含一个子元素(用于显示内容)，设置子元素的左右padding或者margin(防止显示内容被左右两列覆盖) 3、左右列设置固定的宽度 4、浮动的元素与浮动的元素同样会受盒子模型的影响而正常元素一样排列，这个时候，我们给浮动的元素设置margin负值调整具体的位置 5、左列元素我们希望它移动到最左边，设置margin-left:100%，这个100%是相对父元素的，因为它与中间列同属一个父元素，所以刚好移动到最左边 6、右列元素因为设置了浮动，并没有紧挨着左列元素，而是遇到中间列的元素边框排在了其身后，设置margin-left：自身宽度，使他排列在最右边 具体设置可以修改上图参数观看变化过程 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:2","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"圣杯布局 圣杯布局与双飞翼布局的不同点在于，左中右三列包含在同一个父元素下，中间列设置padding或者margin留出位置给左右两列 左列元素尽管设置了margin-left:-100%,仍然无法移动到最右边，因为它与中间列同属一个父元素，所以需要利用position属性往左移动自身宽度 右列元素有两种方法设置，1)设置margin-right:-自身宽度，其元素后面的元素会往前移动 2)设置position:相对定位，margin-left：-自身宽度，right:-自身宽度; See the Pen 圣杯布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:3","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["JavaScript"],"content":"浅谈一下变量关键字","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":" ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:0","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"var、let、const的几点区别 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:1","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"1、重复声明 let和const都不允许，var可以。为了规范编程减少使用var，其实在vueAPI中也大多数情况下用const去初始化数据，主要是要获得响应式的数据，我们都不会直接去重新赋值 \u003c!-- 基本数据类型 --\u003e const name = 'tom' name = 'jack' //error \u003c!-- 引用数据类型 --\u003e const person = { name:'tom', age:22 } person = { name:'leon', age:33 } //error //采用另一种修改方式 person.name = 'leon' //成功修改 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:2","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"2、变量提升： var会提升变量声明到当前作用域的前面 function test() { var i = 22 } console.log(i) //22 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:3","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"3、暂时性死区 只要作用域内存在let、const，他们所声明的变量或常量就会自动绑定这个区域，不再受外部作用域的影响 function test() { let i = 22 } console.log(i) //error ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:4","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"4、window对象的属性和方法 全局作用域下，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法 var age = 18 console.log(window.age) ==18 function add(){ console.log('你好') } window.add === add //全等 但是使用const\\let声明的变量或function都不会变为window中的 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:5","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"5、作用域链 function func(){ for(let i = 0; i \u003c 4;i ++){ console.log(i) } } //当函数被调用即产生了一个函数作用域 func() // 1 console.log(i) //error i 未定义 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:6","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 一些块级作用域 {} //花括号以及带有{}的一些方法 for(let){} // 需要和const let 配合 while(){} if(){} // 等等 function fuc(){} //函数作用域 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:7","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"应用 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:8","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"绑定事件案例 \u003cbutton\u003e按钮1\u003c/button\u003e \u003cbutton\u003e按钮2\u003c/button\u003e \u003cbutton\u003e按钮3\u003c/button\u003e \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } 当我们点击分别点击按钮时，期望得到的时相应的i，即0，1，2(实际全是2)。但是由于绑定事件属于{块级作用域}，而var定义的i是具有函数级作用域的，所有在每一个绑定事件的{块级作用域}中是找不到i的值，故会出到外层查找，外层循环结束后i的值为2。 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:9","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法一 在ES6之前我们可以用闭包的办法解决 \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { //创建一个即时函数 (function(index){ btn[i].addEventListener('click',function(){ console.log(index) }) })(i) } ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:10","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:11","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法二 ES6以后，我们采用let 或 const 锁定作用域范围，达到和上面采用闭包一样的效果 \u003c!-- 绑定点击事件 --\u003e let btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(let i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } //0 1 2 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:12","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:13","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"}]