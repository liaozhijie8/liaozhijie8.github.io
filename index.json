[{"categories":["书签整理"],"content":"学习书签集合","date":"2022-07-19","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["书签整理"],"content":" JavaScript学习书签 各种对象方法 ","date":"2022-07-19","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/:0:0","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["JavaScript"],"content":"箭头函数 ","date":"2022-07-19","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:0:0","tags":["箭头函数","ES6"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"浅谈一下变量关键字","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":" ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:0","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"var、let、const的几点区别 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:1","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"1、重复声明 let和const都不允许，var可以。为了规范编程减少使用var，其实在vueAPI中也大多数情况下用const去初始化数据，主要是要获得响应式的数据，我们都不会直接去重新赋值 \u003c!-- 基本数据类型 --\u003e const name = 'tom' name = 'jack' //error \u003c!-- 引用数据类型 --\u003e const person = { name:'tom', age:22 } person = { name:'leon', age:33 } //error //采用另一种修改方式 person.name = 'leon' //成功修改 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:2","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"2、变量提升： var会提升变量声明到当前作用域的前面 function test() { var i = 22 } console.log(i) //22 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:3","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"3、暂时性死区 只要作用域内存在let、const，他们所声明的变量或常量就会自动绑定这个区域，不再受外部作用域的影响 function test() { let i = 22 } console.log(i) //error ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:4","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"4、window对象的属性和方法 全局作用域下，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法 var age = 18 console.log(window.age) ==18 function add(){ console.log('你好') } window.add === add //全等 但是使用const\\let声明的变量或function都不会变为window中的 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:5","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"5、作用域链 function func(){ for(let i = 0; i \u003c 4;i ++){ console.log(i) } } //当函数被调用即产生了一个函数作用域 func() // 1 console.log(i) //error i 未定义 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:6","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 一些块级作用域 {} //花括号以及带有{}的一些方法 for(let){} // 需要和const let 配合 while(){} if(){} // 等等 function fuc(){} //函数作用域 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:7","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"应用 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:8","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"绑定事件案例 \u003cbutton\u003e按钮1\u003c/button\u003e \u003cbutton\u003e按钮2\u003c/button\u003e \u003cbutton\u003e按钮3\u003c/button\u003e \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } 当我们点击分别点击按钮时，期望得到的时相应的i，即0，1，2(实际全是2)。但是由于绑定事件属于{块级作用域}，而var定义的i是具有函数级作用域的，所有在每一个绑定事件的{块级作用域}中是找不到i的值，故会出到外层查找，外层循环结束后i的值为2。 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:9","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法一 在ES6之前我们可以用闭包的办法解决 \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { //创建一个即时函数 (function(index){ btn[i].addEventListener('click',function(){ console.log(index) }) })(i) } ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:10","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:11","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法二 ES6以后，我们采用let 或 const 锁定作用域范围，达到和上面采用闭包一样的效果 \u003c!-- 绑定点击事件 --\u003e let btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(let i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } //0 1 2 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:12","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:13","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["Vue"],"content":"vue各版本的API别 ","date":"2022-07-18","objectID":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/:0:0","tags":["API","vue"],"title":"Vue不同版本API","uri":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/"},{"categories":["Vue"],"content":"Vuex is a state management pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":" State Management Pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"为什么需要状态管理？ 在回答这个问题之前我们先看一下不用Vuex,是如何进行组件之间的数据传递的 以Vue2为例子，组件之间的数据共享大致分为三部分 类型 方式 父组件-\u003e子组件 子组件中,通过 props 来自定义属性 父组件中,负责把数据，通过 v-bind: 绑定给子组件 子组件-\u003e父组件 子组件中调用 this.$emit() 来触发自定义事件. 父组件中，通过 v-on: 来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件传递过来的数据。. 兄弟组件共享数据 EventBus 其实原理与子组件传父组件相似 显然这种方式对于单个数据或者少量数据处理是没有问题的，但是官方提出了两个问题 Multiple views may depend on the same piece of state. Actions from different views may need to mutate the same piece of state. 当我们需要多组件共享数据或者处理数据时，会变得繁琐，尤其是当嵌套组件过多时，单向数据的传递会变得尤为复杂且低效 为解决这两个问题,需要一个全局管理数据的工具—–Vuex ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:1","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"如何使用Vuex 组成部分 组成 作用 State 存放全局数据 Getters 简单计算处理State中的数据,再传递给组件 Mutations 通过commit方法改变State中的数据,执行的是同步操作 Actions 通过dispatch方法改变State中的数据,执行的是异步操作 Modules 模块化 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:2","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"使用步骤 利用createStore方法新建实例 import { createStore } from 'vuex' import index from './cart/index' const store = createStore({ modules: { cart: index //子模块 } }) export default store 在main函数中注册 import { createApp } from 'vue' import App from './App.vue' import store from './store' //引入注册 const app = createApp(App) app.use(store) app.mount('#app') 子模块定义数据方法 import { Goods } from './interface' export default { // 开启空间命名 namespaced: true, state: { goods: [ { id: 0, name: '牙刷', price: 20, count: 22 }, { id: 1, name: '平板', price: 2, count: 322 }, { id: 2, name: '背包', price: 210, count: 266 }, { id: 3, name: '电脑', price: 203, count: 255 }, { id: 4, name: '手机', price: 204, count: 23 } ], totalPrice: 0 }, getters: { getPrice: (state: Goods) =\u003e (price: number) =\u003e { return state.goods.filter(d =\u003e d.price \u003e price) } }, mutations: { addPrice(state: Goods, id: number) { state.totalPrice += state.goods[id].price } }, actions: { fetchTotalPrice({ commit }, payload: number) { commit('addPrice', payload) } } } 在组件中使用 需要注意引用子模块的方式 import { useStore } from 'vuex' setup() { const store = useStore() // 引用方法store.属性.模块名称.数据 const goods = computed(() =\u003e store.state.cart.goods) const totalPrice = computed(() =\u003e store.state.cart.totalPrice) const chooseGoods = (id: number) =\u003e { // 使用action store.dispatch('cart/fetchTotalPrice', id) } // // // 使用getter const priceGoods = computed(() =\u003e store.getters['cart/getPrice'](100)) return { goods, priceGoods, totalPrice, chooseGoods } } }) ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:3","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"全新的版本pinia Why should I use Pinia? ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:4","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"关于 王者荣耀全能烹饪师 ","date":"2022-07-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]