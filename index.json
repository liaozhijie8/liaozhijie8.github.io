[{"categories":["JavaScript"],"content":"箭头函数 ","date":"2022-07-19","objectID":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/:0:0","tags":["箭头函数","ES6"],"title":"箭头函数","uri":"/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"var、let、const的几点区别 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:1","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"1、重复声明 let和const都不允许，var可以。为了规范编程减少使用var，其实在vueAPI中也大多数情况下用const去初始化数据，主要是要获得响应式的数据，我们都不会直接去重新赋值 \u003c!-- 基本数据类型 --\u003e const name = 'tom' name = 'jack' //error \u003c!-- 引用数据类型 --\u003e const person = { name:'tom', age:22 } person = { name:'leon', age:33 } //error //采用另一种修改方式 person.name = 'leon' //成功修改 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:2","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"2、变量提升： var会提升变量声明到当前作用域的前面 function test() { var i = 22 } console.log(i) //22 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:3","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"3、暂时性死区 只要作用域内存在let、const，他们所声明的变量或常量就会自动绑定这个区域，不再受外部作用域的影响 function test() { let i = 22 } console.log(i) //error ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:4","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"4、window对象的属性和方法 全局作用域下，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法 var age = 18 console.log(window.age) ==18 function add(){ console.log('你好') } window.add === add //全等 但是使用const\\let声明的变量或function都不会变为window中的 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:5","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"5、作用域链 function func(){ for(let i = 0; i \u003c 4;i ++){ console.log(i) } } func() //当函数被调用即产生了一个函数作用域 console.log(i) //error i 未定义 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:6","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 一些块级作用域 {} //花括号以及带有{}的一些方法 for(let){} // 需要和const let 配合 while(){} if(){} // 等等 function fuc(){} //函数作用域 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:7","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"应用 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:8","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"绑定事件案例 \u003cbutton\u003e按钮1\u003c/button\u003e \u003cbutton\u003e按钮2\u003c/button\u003e \u003cbutton\u003e按钮3\u003c/button\u003e \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } 当我们点击分别点击按钮时，期望得到的时相应的i，即0，1，2(实际全是2)。但是由于绑定事件属于{块级作用域}，而var定义的i是具有函数级作用域的，所有在每一个绑定事件的{块级作用域}中是找不到i的值，故会出到外层查找，外层循环结束后i的值为2。 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:9","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法一 在ES6之前我们可以用闭包的办法解决 \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { //创建一个即时函数 (function(index){ btn[i].addEventListener('click',function(){ console.log(index) }) })(i) } ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:10","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:11","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法二 ES6以后，我们采用let 或 const 锁定作用域范围，达到和上面采用闭包一样的效果 \u003c!-- 绑定点击事件 --\u003e let btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(let i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } //0 1 2 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:12","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2022-07-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:13","tags":["ES6","变量"],"title":"ES6变量","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["前端"],"content":"vue各版本的API别 ","date":"2022-07-18","objectID":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/:0:0","tags":["API","vue"],"title":"Vue不同版本API","uri":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/"},{"categories":["前端"],"content":"vue的数据管理对比 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"关于 王者荣耀全能烹饪师 ","date":"2022-07-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]