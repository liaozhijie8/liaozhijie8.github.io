[{"categories":["Vue"],"content":"基本概念 在过去的10年时间里，网页变得更加动态化和强大了。通过JavaScript，我们已经可以把很多传统的服务端代码放到浏览器中。身为一名前端工程师，我们所面临的需求变得越来越复杂。当应用程序开始变复杂后，我们需要频繁操作DOM。由于缺乏正规的组织形式，我们的代码变得非常难以维护。这本质上是命令式操作DOM的问题，我们曾经用jQuery操作DOM写需求，但是当应用程序变复杂后，代码就像一坨意大利面一样，有点难以维护。我们无法继续使用命令式操作DOM，所以Vue.js提供了声明式操作DOM的能力来解决这个问题。 通过描述状态和DOM之间的映射关系，就可以将状态渲染成DOM呈现在用户界面中，也就是渲染到网页上。 Vue.js Vue允许你将一个网页分割成可复用的组件，每个组件都有自己的HTML、CSS和JavaScript来渲染网页中一个对应的位置。 如果要构建一个大型应用，就需要先搭建项目，配置一些开发环境等。Vue.js提供了一个命令行工具，它让快速初始化一个真实的项目工程变得非常简单。 我们甚至可以使用Vue.js的单文件组件，它包含各自的HTML、JavaScript以及带作用域的CSS或SCSS。单文件组件可以使项目架构变得非常清晰、可维护。 Vue定位为渐进式框架，把框架分层，最核心的部分是视图层渲染，往外是组件机制，路由机制，状态管理，最外层是构建工具。 框架分层 所谓分层，就是说你既可以只用最核心的视图层渲染功能来快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js有足够的灵活性来适应不同的需求，所以你可以根据自己的需求选择不同的层级。 ","date":"2023-01-31","objectID":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/:0:1","tags":[""],"title":"框架设计","uri":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"},{"categories":["Vue"],"content":"权衡的艺术 声明式与命令式编程 从范式上来看，视图层框架通常分为命令式和声明式，它们各有优缺点。 早年间流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是关注过程。例如，我们把下面这段话翻译成对应的代码： 01 - 获取 id 为 app 的 div 标签 02 - 它的文本内容为 hello world 03 - 为其绑定点击事件 04 - 当点击时弹出提示：ok 对应的代码: 01 $('#app') // 获取 div 02 .text('hello world') // 设置文本内容 03 .on('click', () =\u003e { alert('ok') }) // 绑定点击事件 可以看到，自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉。 那么，什么是声明式框架呢？与命令式框架更加关注过程不同，声明式框架更加关注结果。结合 Vue.js，我们来看看如何实现上面自然语言描述的功能： 01 \u003cdiv @click=\"() =\u003e alert('ok')\"\u003ehello world\u003c/div\u003e 这段类 HTML 的模板就是 Vue.js 实现如上功能的方式。可以看到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心，Vue.js 的内部实现采用的是命令式的，而暴露给用户的是声明式。 性能与可维护性的权衡 先说结论:声明式代码的性能不优于命令式代码的性能。 假设我们要修改div中的文本,采用命令式可以这样直接修改，并且没有比这个更简单的方法了， 01 div.textContent = 'hello vue3' // 直接修改 可以看到，理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果： 01 \u003c!-- 之前： --\u003e 02 \u003cdiv @click=\"() =\u003e alert('ok')\"\u003ehello world\u003c/div\u003e 03 \u003c!-- 之后： --\u003e 04 \u003cdiv @click=\"() =\u003e alert('ok')\"\u003ehello vue3\u003c/div\u003e 对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是： 01 div.textContent = 'hello vue3' 如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有： 命令式代码的更新性能消耗 = A 声明式代码的更新性能消耗 = B + A 可以看到，声明式代码会比命令式代码多出找出差异的性能消耗，因此最理想的情况是，当找出差异的性能消耗为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式。这符合前文中给出的性能结论：声明式代码的性能不优于命令式代码的性能。 既然在性能层面命令式代码是更好的选择，那么为什么 Vue.js 要选择声明式的设计方案呢？原因就在于声明式代码的可维护性更强。从上面例子的代码中我们也可以感受到，在采用命令式代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素的创建、更新、删除等工作。而声明式代码展示的就是我们要的结果，看上去更加直观，至于做事儿的过程，并不需要我们关心，Vue.js 都为我们封装好了。 虚拟DOM 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗，因此，如果我们能够最小化找出差异的性能消耗，就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。 虚拟DOM通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。 虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。 虚拟DOM能够让我们不用付出太多的努力（写声明式代码），还能够保证应用程序的性能下限，让应用程序的性能不至于太差，甚至想办法逼近命令式代码的性能 innerHTML、虚拟 DOM 以及原生 JavaScript 在更新页面时的性能 原生 DOM 操作方法的心智负担最大，因为你要手动创建、删除、修改大量的 DOM 元素。但它的性能是最高的，不过为了使其性能最佳，我们同样要承受巨大的心智负担。另外，以这种方式编写的代码，可维护性也极差。而对于 innerHTML 来说，由于我们编写页面的过程有一部分是通过拼接 HTML 字符串来实现的，这有点儿接近声明式的意思，但是拼接字符串总归也是有一定心智负担的，而且对于事件绑定之类的事情，我们还是要使用原生 JavaScript 来处理。如果 innerHTML 模板很大，则其更新页面的性能最差，尤其是在只有少量更新时。最后，我们来看看虚拟 DOM，它是声明式的，因此心智负担小，可维护性强，性能虽然比不上极致优化的原生 JavaScript，但是在保证心智负担和可维护性的前提下相当不错。 运行时和编译时 当设计一个框架的时候，我们有三种选择：纯运行时的、运行时 + 编译时的或纯编译时的。 运行时 编写一个Render函数，用户可以为该函数提供一个树型结构的数据对象，然后使用Render函数，根据该对象递归地将数据渲染成 DOM 元素。 数据对象如下: 01 const obj = { 02 tag: 'div', 03 children: [ 04 { tag: 'span', children: 'hello world' } 05 ] 06 } Render函数 01 function Render(obj, root) { 02 const el = document.createElement(obj.tag) 03 if (typeof obj.children === 'string') { 04 const text = document.createTextNode(obj.children) 05 el.appendChild(text) 06 } else if (obj.children) { 07 // 数组，递归调用 Render，使用 el 作为 root 参数 08 obj.children.forEach((child) =\u003e Render(child, el)) 09 } 10 11 // 将元素添加到 root 12 root.appendChild(el) 13 } 把数据对象交给Render函数处理 01 const obj = { 02 tag: 'div', 03 children: [ 04 { tag: 'span', children: 'hello world' } 05 ] 06 } 07 // 渲染到 body 下 08 Render(obj, document.body) 用户在使用它渲染内容时，直接为 Render 函数提供了一个树型结构的数据对象。这里面不涉及任何额外的步骤，用户也不需要学习额外的知识。但是有一天，你的用户抱怨说：“手写树型结构的数据对象太麻烦了，而且不直观，能不能支持用类似于 HTML 标签的方式描述树型结构的数据对象呢？”你看了看现在的 Render 函数，然后回答：“抱歉，暂不支持。” 编译时 为了解决纯运行时，编写树形结构对象的痛点，引入编译的手段，把 HTML 标签编译成树型结构的数据对象，从而可以继续使用 Render 函数 把 HTML 标签编译成树型结构的数据对象 Compiler程序的作用就是把 HTML 字符串编译成树型结构的数据对象，让用户分别调用 Compiler 函数和 Render 函数： 01 const html = ` 02 \u003cdiv\u003e 03 \u003cspan\u003ehello world\u003c/span\u003e 04 \u003c/div\u003e 05 ` 06 // 调用 Compiler 编译得到树型结构的数据对象 07 const obj = Compiler(html) 08 // 再调用 Render 进行渲染 09 Render(obj, document.body) 这是一个运行时 + 编译时的框架雏形。它既支持运行时，用户可以直接提供数据对象从而无须编译；又支持编译时，用户可以提供 HTML 字符串，我们将其编译为数据对象后再交给运行时处理。准确地说，上面的代码其实是运行时编译，意思是代码运行的时候才开始编译，而这会产生一定的性能开销，因此我们也可以在构建的时候就执行 Compiler 程序将用户提供的内容编译好，等到运行时就无须编译了，这对性能是非常友好的。 纯编译时 既然编译器可以把 HTML 字符串编译成数据对象，那么能不能直接编译成命令式代码呢？ 将 HTML 字符串编译为命令式代码的过程 这样我们只需要一个 Compiler 函数就可以了，连 Render 都不需要了。其实这就变成了一个纯编译时的框架，因为我们不支持任何运行时内容，用户的代码通过编译器编译后才能运行。 总结 纯运行时的框架。 由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可","date":"2023-01-31","objectID":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/:0:2","tags":[""],"title":"框架设计","uri":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"},{"categories":["Vue"],"content":"Vue渲染视图过程 在Vue.js中，我们使用模板来描述状态与DOM之间的映射关系。Vue.js通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面， 模板转换成视图的过程 虚拟DOM的终极目标是将虚拟节点（vnode）渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。 为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。 虚拟DOM的执行过程 1）提供与真实DOM节点所对应的虚拟节点vnode。 2）将虚拟节点vnode和旧虚拟节点oldVnode进行比对，然后更新视图。 VNode 什么是VNode 它是Vue.js中存在的一个类，使用它可以实例化不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。 例如，DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。 01 export default class VNode { 02 constructor (tag, data, children, text, elm, context, componentOptions, asyncFactory) { 03 this.tag = tag 04 this.data = data 05 this.children = children 06 this.text = text 07 this.elm = elm 08 this.ns = undefined 09 this.context = context 10 this.functionalContext = undefined 11 this.functionalOptions = undefined 12 this.functionalScopeId = undefined 13 this.key = data \u0026\u0026 data.key 14 this.componentOptions = componentOptions 15 this.componentInstance = undefined 16 this.parent = undefined 17 this.raw = false 18 this.isStatic = false 19 this.isRootInsert = true 20 this.isComment = false 21 this.isCloned = false 22 this.isOnce = false 23 this.asyncFactory = asyncFactory 24 this.asyncMeta = undefined 25 this.isAsyncPlaceholder = false 26 } 27 28 get child () { 29 return this.componentInstance 30 } 31 } vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。 vnode表示一个真实的DOM元素，所有真实的DOM节点都使用vnode创建并插入到页面中:渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后插入到页面渲染视图。 VNode创建DOM并插入到视图 VNode的作用 由于每次渲染视图时都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的vnode缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之间有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM。 Vue.js目前对状态的侦测策略采用了中等粒度。当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图。 也就是说，只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染。 如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。这也是vnode最重要的一个作用。 patch 它虚拟DOM最核心的部分，可以将vnode渲染成真实的DOM。 patch也可以叫作patching算法，通过它渲染真实DOM时，并不是暴力覆盖原有DOM，而是比对新旧两个vnode之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。这一点从名字就可以看出，patch本身就有补丁、修补等意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。 之所以要这么做，主要是因为DOM操作的执行速度远不如JavaScript的运算速度快。因此，把大量的DOM操作搬运到JavaScript中，使用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提升性能。这本质上其实是使用JavaScript的运算成本来替换DOM操作的执行成本，而JavaScript的运算速度要比DOM快很多，这样做很划算，所以才会有虚拟DOM。 创建新增的节点； 删除已经废弃的节点； 修改需要更新的节点。 模板编译原理 模板编译成渲染函数有三部分内容：先将模板解析成AST，然后遍历AST标记静态节点，最后使用AST生成代码字符串。这三部分内容分别对应三个模块：解析器、优化器和代码生成器。 模板编译在整个渲染过程中的位置 Vue.js提供了模板语法，允许我们声明式地描述状态和DOM之间的绑定关系，然后通过模板来生成真实DOM并将其呈现在用户界面上。 在底层实现上，Vue.js会将模板编译成虚拟DOM渲染函数。当应用内部的状态发生变化时，Vue.js可以结合响应式系统，聪明地找出最小数量的组件进行重新渲染以及最少量地进行DOM操作 解析器 解析器的作用是通过模板得到AST（抽象语法树）。 生成AST的过程需要借助HTML解析器，当HTML解析器触发不同的钩子函数时，我们可以构建出不同的节点。随后，我们可以通过栈来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。最终，当HTML解析器运行完毕后，我们就可以得到一个完整的带DOM层级关系的AST。HTML解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。 解析器内部也分了好几个子解析器，比如HTML解析器、文本解析器以及过滤器解析器，其中最主要的是HTML解析器 模板: 01 \u003cdiv\u003e 02 \u003cp\u003e{{name}}\u003c/p\u003e 03 \u003c/div\u003e 转换成AST后： 01 { 02 tag: \"div\" 03 type: 1, 04 staticRoot: false, 05 static: false, 06 plain: true, 07 parent: undefined, 08 attrsList: [], 09 attrsMap: {}, 10 children: [ 11 { 12 tag: \"p\" 13 type: 1, 14 staticRoot: false, 15 static: false, 16 plain: true, 17 parent: {tag: \"div\", ...}, 18 attrsList: [], 19 attrsMap: {}, 20 children: [{ 21 type: 2, 22 text: \"{{name}}\", 23 static: false, 24 expression: \"_s(name)\" 25 }] 26 } 27 ] 28 } AST是用JavaScript中的对象来描述一个节点，一个对象表示一个节点，对象中的属性用来保存节点所需的各种数据。比如，parent属性保存了父节点的描述对象，children属性是一个数组，里面保存了一些子节点的描述对象。再比如，type属性表示一个节点的类型等。当很多个独立的节点通过parent属性和children属性连在一起时，就变成了一个树，而这样一个用对象描述的节点树其实就是AST。 优化器 优化器的作用是在AST中找出静态子树并打上标记，这样做有两个好处： 每次重新渲染时，不需要为静态子树创建新节点； 在虚拟DOM中打补丁的过程可以跳过。 优化器的内部实现其实主要分为两个步骤： (1) 在AST中找出所有静态节点并打上标记； (2) 在AST中找出所有静态根节点并打上标记。 通过递归的方式从上向下标记静态节点时，如果一个节点被标记为静态节点，但它的子节点却被标记为动态节点，就说明该节点不是静态节点，可以将它改为动态节点。静态节点的特征是它的子节点必须是静态节点。 标记完静态节点之后需要标记静态根节点，其标记方式也是使用递归的方式从上向下寻找，在寻找的过程中遇到的第一个静态节点就为静态根节点，同时不再向下继续查找。 但有两种情况比较特殊：一种是如果一个静态根节点的子节点只有一个文本节点，那么不会将它标记成静态根节点，即便它也属于静态根节点；另一种是如果找到的静态根节点是一个没有子节点的静","date":"2023-01-31","objectID":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/:0:3","tags":[""],"title":"框架设计","uri":"/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"},{"categories":["性能优化"],"content":" 前端性能优化 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:0","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"纵观http请求的过程，可以得出一些请求过程中的潜在的性能优化 dns是否可以通过缓存减少dns查询的时间? 网络请求的过程走最近的网络环境？ 相同的静态资源是否可以缓存？ 能否减少请求http请求大小？ 减少http请求 服务端渲染 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:1","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"资源的合并与压缩 减少http请求的数量 减少请求资源的大小 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:2","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"html 压缩 webpack打包压缩 nodejs 提供了html-minifier工具 后端模板引擎渲染压缩 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:3","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"css 压缩 clean-css库 无效代码删除 css语义合并-有些属性重复 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:4","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"js 压缩与混乱 —uglifyjs2 无效字符的删除 剔除注释 代码语义的缩减和优化 代码保护-降低代码的可读性 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:5","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"文件合并 存在的问题:1、首屏渲染问题 2、缓存失效问题 公共库合并 不同页面的合并 开启gzip ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:6","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"图片优化 一、不同格式图片常用的业务场景 jpg有损压缩，压缩率高，不支持透明——应用与大部分不需要透明图片的业务场景 png支持透明，浏览器兼容性好——应用于大部分需要透明图片的业务场景 webp压缩程度更好，在ios webview有兼容性问题——安卓 svg矢量图，拉伸不失真，代码内嵌,相对较小,图片样式相对简单的场景——图片样式相对简单的业务场景，icon,logo 二、图片压缩——针对真实图片情况，舍弃一些相对无关紧要的色彩信息 CSS精灵图 把网站上用到的一些图片整合到一张单独的图片中(减少网站的HTTP请求数量)，利用CSS背景属性进行调整，需要控制精灵图的大小，过大可能会导致加载过慢，整个页面内容显示不正常。 Image inline 将图片的内容内嵌到html当中,减少网站HTTP请求数量 使用矢量图 使用SVG进行矢量图的绘制 使用iconfont解决icon问题 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:7","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"HTML渲染过程 一、需要考虑的点 顺序执行、并发执行 词法分析 并发加载 并发上限 是否阻塞 1)CSS阻塞 css head中阻塞页面的渲染 css阻塞js的执行 css不阻塞外部脚本的加载，外部的脚本是基于已经加载完的css样式去操作dom 2)js阻塞 直接引入(srcipt src=‘js’)会导致阻塞页面的渲染 js不阻塞资源的加载，会预先扫描，预加载 js顺序执行，会阻塞后续js逻辑的执行(单线程) 依赖关系 1)页面渲染依赖于css的加载 2)js的执行顺序的依赖关系 3)js逻辑对于dom节点的依赖关系 js引入方式 直接引入 defer引入 async 异步动态引入js 二、加载和执行的一些优化点 css样式表置顶 用link 代替 import js 脚本置底 合理使用js的异步加载能力 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:8","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"懒加载与预加载 一、懒加载 图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景使用 减少无效资源的加载 并发加载的资源过多会阻塞js的加载，影响网站的正常使用 二、预加载 图片等静态资源在使用之前的提前请求 资源使用到时能从缓存中加载，提升用户体验 页面展示的依赖关系维护 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:9","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"重绘与回流 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢 解决办法： 1)寻找替代会引起重绘回流的方案(避免使用触发重绘，回流的CSS属性) 2)如无法避免，将频繁重绘回流的DOM元素单独作为一个独立图层，一次插入到布局中，那么这个dom元素的重绘回流只会影响一次，而且在独立图层里 一、回流 当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建——回流 当页面布局和几何属性改变时就需要回流 1)触发的条件 盒子模型相关属性——width、height、padding、margin、display、border 定位属性及浮动——top、bottom、left、right、position、float、clear 改变节点内部文字结构—— text-align overflow-y font-weight overflow font-family line-height vertical-align white-space font-size、 二、重绘 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color——重绘 三、新建DOM的过程 获取DOM后分割为多个图层 对每个图层的节点计算样式结果(Recalculate style 样式重计算) 为每个节点生成图形和位置(Layout 回流和重布局) 将每个节点绘制填充到图层位图中(Paint Setup和Paint 重绘) 图层作为纹理上传至gpu 符合多个图层到页面上生成最终屏幕图像(Composite Layers 图层重组) 四、浏览器绘制DOM的过程是这样子的： 获取 DOM 并将其分割为多个层（layer），将每个层独立地绘制进位图（bitmap）中 将层作为纹理（texture）上传至 GPU，复合（composite）多个层来生成最终的屏幕图像 left/top/margin之类的属性会影响到元素在文档中的布局，当对布局（layout）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。 transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。 通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。 五、chrome创建图层的条件 ——将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中 3D或透视变换 CSS属性使用加速视频解码的 video 元素 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 canvas 元素 复合插件(如 Flash) 进行 opacity/transform 动画的元素拥有加速 CSS filters 的元素元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里) 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染) 总结：对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧 六、优化点总结 用translate替代top属性 top会触发layout，但translate不会 用opacity代替visibility opacity不会触发重绘也不会触发回流，只是改变图层alpha值，但是必须要将这个图片独立出一个图层 visibility会触发重绘 不要一条一条的修改DOM的样式，预先定义好class，然后修改DOM的className 把DOM离线后修改，比如：先把DOM给display:none（有一次reflow），然后你修改100次，然后再把它显示出来 不要把DOM节点的属性值放在一个循环里当成循环的变量 offsetHeight、offsetWidth每次都要刷新缓冲区，缓冲机制被破坏 先用变量存储下来 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局，div只会影响后续样式的布局 动画实现的速度的选择，选择合适的动画速度 根据performance量化性能优化 对于动画新建图层 启用gpu硬件加速(并行运算)，gpu加速意味着数据需要从cpu走总线到gpu传输，需要考虑传输损耗. transform:translateZ(0) transform:translate3D(0) ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:10","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"浏览器存储 一、cookie 用于浏览器端和服务器端的交互(主要作用，维护用户状态) 客户端自身数据的存储(在localstorage诞生前的主要手段) cookie中在相关域名下面导致cdn的流量损耗——解决方案：cdn的域名和主站域名要分开 二、LocalStorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 三、SessionStorage 会话级别的浏览器存储(和localstorage唯一的区别) 场景： 对于表单信息的维护 四、indexedDB IndexedDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然WebStorage对于存储叫少量的数据很管用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 场景：为应用创建离线版本 五、PWA PWA(Progressive Web Apps)是一种Web App新模型，并不是具体指某一种前言的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强Web App的用户体验 检测是不是一个渐进式 web app 1)当前手机在弱网环境下能不能加载出来 2)离线环境下能不能加载出来 特点 1)可靠：没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面 2)快速：针对网页渲染及网络数据访问有较好的优化 3)融入(Engaging)：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性 六、service worker 是一个脚本，浏览器独立于当前页面，将其在后台运行，为实现一些不依赖页面的或者用户交互的特性打开了一扇大门。在未来这些特性将包括消息推送，背景后台同步， geofencing(地理围栏定位)，但他将推出的第一个首要的特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:11","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"浏览器缓存 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:12","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["前端工程化"],"content":" 前端工程化概念 前端工程化解决了什么问题 js全局作用域冲突 编码规范问题 资源合并和压缩问题 高版本js预发降级 ","date":"2022-11-05","objectID":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/:0:0","tags":["概念"],"title":"前端工程化","uri":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"categories":["项目全流程"],"content":"git:分布式管理 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:0:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"一、基础概念 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"三个区域 工作区→暂存区→git仓库 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:1","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"三个状态 以修改、以暂存、已更新 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:2","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"安装配置 image.png ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:3","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"创建仓库 一、将现有目录初始化为仓库 1、在项目目录中，打开git Bash，输入git init 2、查下文件状态 git status 或者 git status -s 3、添加到暂存区 “git add .“或者 git add 指定名称 4、提交更新git commit -m “提交提示信息” 二、修改文件后提交流程 如果已经添加到更新的文件发生了修改，可以用git status -s 查看 然后再次执行git add .提交更新到暂存区，利用git commit -m 提交更新 三、撤销对文件的修改 注意：此时的文件并没有提交到更新仓库，撤销将是不可逆的，一般很少用的 四、移除暂存区中的文件 git reset HEAD + 指定文件名称 或者.移除全部文件出暂存区 五、直接提交到仓库 git commit -a -m “描述消息” 六、移除文件 1、工作区（本地）和仓库的文件都一起移除（不可逆） git rm -f “文件名” 2、仓库文件移除，只保留工作区 git rm –cached “文件名” 七、忽略文件 参考vue脚手架自带文件 八、查看提交历史 git log -2 表示查看最近俩条 回退版本 git reset –hard +对应的commit号 回到回退前的版本号 先查看所有操作日记，包括已经回退了的 git reflog git reset –hard 回退到指定版本 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:4","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"二、远程仓库操作 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"1、绑定 HTTPS ：不需要配置但是每次访问都需要输入github账号密码。 1）、绑定仓库 git remote add origin https://github.com/liaozhijie8/vue3.0_project_zhihu.git git branch -M main git push -u origin main 2）、后续的提交 利用git push 将本地commit的内容提交到远程仓库 SSH ：需要进行额外的配置，之后每次访问都不需要账号密码 1）、获取key http://t.zoukankan.com/emily1130-p-7503546.html 2)、按照提示配置仓库 git push ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:1","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"2、分支 1）、创建分支 git branch 分支名称 →git checkout 分支名称 切换分支 git checkout -b 分支名称 —–新建一个分支并切换到改分支下 2）、合并分支 1、先切换到上一级分支 git checkout 分支名 2、合并分支 git merge 分支名 3）、删除分支 先回到上一层分支中，然后再用git branch -d 下一层分支名称删除分支 4）、分支冲突 打开冲突文件，手动解决冲突 5）、将分支推送到远程仓库 6）、跟踪远程仓库 参考GitHub 7）、拉取远程仓库 git pull 8）、删除远程仓库的分支 git push origin –delete 分支名称 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:2","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["JavaScript"],"content":"随便记录一下","date":"2022-07-26","objectID":"/javascript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0/","tags":["笔记"],"title":"JavaScript红宝书笔记","uri":"/javascript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Vue"],"content":"vue各版本的API别 ","date":"2022-07-18","objectID":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/:0:0","tags":["API","vue"],"title":"Vue不同版本API","uri":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/"},{"categories":["Vue"],"content":"Vuex is a state management pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":" State Management Pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"为什么需要状态管理？ 在回答这个问题之前我们先看一下不用Vuex,是如何进行组件之间的数据传递的 以Vue2为例子，组件之间的数据共享大致分为三部分 类型 方式 父组件-\u003e子组件 子组件中,通过 props 来自定义属性 父组件中,负责把数据，通过 v-bind: 绑定给子组件 子组件-\u003e父组件 子组件中调用 this.$emit() 来触发自定义事件. 父组件中，通过 v-on: 来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件传递过来的数据。. 兄弟组件共享数据 EventBus 其实原理与子组件传父组件相似 显然这种方式对于单个数据或者少量数据处理是没有问题的，但是官方提出了两个问题 Multiple views may depend on the same piece of state. Actions from different views may need to mutate the same piece of state. 当我们需要多组件共享数据或者处理数据时，会变得繁琐，尤其是当嵌套组件过多时，单向数据的传递会变得尤为复杂且低效 为解决这两个问题,需要一个全局管理数据的工具—–Vuex Vuex工作流程 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:1","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"如何使用Vuex 组成部分 组成 作用 State 存放全局数据 Getters 简单计算处理State中的数据,再传递给组件 Mutations 通过commit方法改变State中的数据,执行的是同步操作 Actions 通过dispatch方法调用Mutations中的方法改变State中的数据,执行的是异步操作 Modules 模块化 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:2","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"使用步骤 利用createStore方法新建实例 import { createStore } from 'vuex' import index from './cart/index' const store = createStore({ modules: { cart: index //子模块 } }) export default store 在main函数中注册 import { createApp } from 'vue' import App from './App.vue' import store from './store' //引入注册 const app = createApp(App) app.use(store) app.mount('#app') 子模块定义数据方法 import { Goods } from './interface' export default { // 开启空间命名 namespaced: true, state: { goods: [ { id: 0, name: '牙刷', price: 20, count: 22 }, { id: 1, name: '平板', price: 2, count: 322 }, { id: 2, name: '背包', price: 210, count: 266 }, { id: 3, name: '电脑', price: 203, count: 255 }, { id: 4, name: '手机', price: 204, count: 23 } ], totalPrice: 0 }, getters: { getPrice: (state: Goods) =\u003e (price: number) =\u003e { return state.goods.filter(d =\u003e d.price \u003e price) } }, mutations: { addPrice(state: Goods, id: number) { state.totalPrice += state.goods[id].price } }, actions: { fetchTotalPrice({ commit }, payload: number) { commit('addPrice', payload) } } } 在组件中使用 需要注意引用子模块的方式 import { useStore } from 'vuex' setup() { const store = useStore() // 引用方法store.属性.模块名称.数据 const goods = computed(() =\u003e store.state.cart.goods) const totalPrice = computed(() =\u003e store.state.cart.totalPrice) const chooseGoods = (id: number) =\u003e { // 使用action store.dispatch('cart/fetchTotalPrice', id) } // // // 使用getter const priceGoods = computed(() =\u003e store.getters['cart/getPrice'](100)) return { goods, priceGoods, totalPrice, chooseGoods } } }) ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:3","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"全新的版本pinia Why should I use Pinia? ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:4","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"关于 王者荣耀全能烹饪师 ","date":"2022-07-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["JavaScript"],"content":"关于原型 1.为什么要用原型 【好处】 原型上所有的方法和属性都可以被构造函数【实际开发原型主要共享方法和所有实例公用引用属性】的实例共享。 举个例子 QQUsers是一个构造函数，所有实例化的对象上面都会有一个共有的方法show以及属性commonfriends。 function QQUsers (QQNo_, QQAge_, QQMark_) { this.QQNo = QQNo_;//QQ号 this.QQAge = QQAge_;//Q龄 this.QQMark = QQMark_;//QQ标签 //引用对象类型=引用类型=对象类型=引用数据类型 // 数组也是一种引用数据类型 this.commonfriends = ['骑驴看海', '大漠上的英雄', '坚实的果子', '小草']//共同好友 // 方法也是一种引用数据类型 this.show = function () { console.log(`QQ号:${this.QQNo},QQ龄:${this.QQAge},QQ标注:${this.QQMark}`) console.log(`共同的好友是:${this.commonfriends}`); } } // 对象也叫实例(instance) // QQZhangSan叫做对象变量 对象是等号右边通过new出来的一个实例 而且是运行期间才在堆中开辟对象的内存空间 let QQZhangSan = new QQUsers(\"37834522\", 15, \"王阳明传人\") let QQLisi = new QQUsers(\"30424232\", 10, \"袁隆平的徒弟\") //let QQLiuwu = new QQUsers(\"刘武\", 12, \"飞起来的鸭子\") QQZhangSan.show(); QQLisi.show(); //QQLiuwu.show(); 2.没有用原型会有什么问题? 所有 QQUser 对象【也叫 QQUser 实例】都有相同的好友属性，好友属性用 commonfriends 英文表示，所有 QQUser 对象都有相同的 show 方法。但我们发现每一个 QQUser对象 【也叫 QQUser 实例】都单独分配一个 commonfriends 属性空间和 show 方法空间，浪费了大量内存空间 答案：使用原型解决 ","date":"2022-01-24","objectID":"/%E5%8E%9F%E5%9E%8B/:0:1","tags":["ts"],"title":"原型","uri":"/%E5%8E%9F%E5%9E%8B/"},{"categories":["JavaScript"],"content":"理解原型 1.认识函数+原型定义 ​函数也是一个对象，当真正开始执行函数，执行环境【开发时为浏览器或控制台】会为函数分配一个函数对象变量空间和函数对象空间，函数对象变量用函数名表示，存在栈空间中， 函数对象空间是在堆中开辟的一个内存空间，这个空间中有一个默认的 prototype 属性，这个 prototype 属性就是一个原型对象属性【也叫对象变量】 函数和构造函数的区别 当通过 new 函数()时，此刻这个函数就是构造函数【 日后会演变成TS 类的构造器】 定义：原型【 prototype ] 是定义函数由 JS 自动分配给函数的一个可以被所有构造函数实例对象变量共享的对象变量【也叫对象属性】 2. 如何访问原型对象空间上的属性和方法 构造函数所有实例对象都可以访问型对象空间上的属性和方法 [每一个实例都有默认的 __proto__ 属性，这个 __proto__ 属性指向原型对象空间] 关于__proto____：new 在创建新对象的时候，会赋予新对象一个属性指向构造函数的 prototype 对象空间，这个属性就是 __proto__ 可以直接通过构造函数.prototype 对象属性来访问原型对象空间上的属性和方法 3.1 构造函数实例【也叫对象】如何访问原型对象空间上的属性和方法 构造函数实例访问一个属性和方法，首先从实例空间中查找【当执行环境执行 new 构造函数()时，构造函数中通过 this 定义的属性和方法会分配在这个空间中】，如果找到该属性和方法，就停止查找，表示找到了；如果没有找到，就继续在该实例的原型对象空间中去查找该属性和方法 【实例中默认的 __proto__ 对象 属性指向原型对象空间】 实例正是借助自身的__ proto __对象属性 来查找原型对象空间中的属性和方法，有点像儿子去和爸爸要他没有的东西一样。】 3.2 增加或修改原型对象的属性或方法后， 所有的实例或叫对象立即可以访问的到 【但创建实例后再覆盖原型除外】 ​ 6.Object.prototype ​ 7.原型链+常见的五种原型继承 ​ 8.call/apply/bind方法 ​ 9.new 构造函数底层到底发生了什么 【深入new底层到底发生了什么】 ​ ​ ","date":"2022-01-24","objectID":"/%E5%8E%9F%E5%9E%8B/:0:2","tags":["ts"],"title":"原型","uri":"/%E5%8E%9F%E5%9E%8B/"},{"categories":["书签整理"],"content":"学习书签集合","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["书签整理"],"content":" JavaScript学习书签 各种对象方法 JavaScript 中 call()、apply()、bind() 的用法 ES6 教程 CSS学习书签 Flex 布局语法教程 CSS灵感 ","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/:0:0","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["CSS"],"content":"一次解决所有居中烦恼","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"水平居中 根据元素的类型不同可以分为两类情况 一类使行内元素，它不能设置宽高，所以需要给其父元素设置一个text-align: center; 一类使块级元素，其可以设置宽高， 在自身已经设置宽高具体参数的情况下，可以给margin：0 auto 利用position属性，相对父元素，移动左边或右边50%，然后再设置margin调整位置 See the Pen 各种水平居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:1","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"垂直居中 See the Pen 垂直居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:2","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"flex就是好用","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":" Flex 布局语法教程 ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:0","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"flex实现双飞布局 父元素设置flex，项目元素设置比例即可实现布局 See the Pen flex布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:1","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"画颗骰子 设置项目元素自身属性align-self调节垂直方向位置 See the Pen flex布局骰子 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:2","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"float布局页面","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":" 经典的双飞翼与圣杯布局，主要利用了CSS盒子模型的特性，以float布局为主要方法，结合Position属性。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:0","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"前置知识了解 CSS盒子模型 我们需要先了解CSS的盒子模型，详细的参考标题链接内容，关键点在于当我们指定一个CSS元素的宽度和高度属性时，只是设置内容区域的宽度和高度，要知道，完整大小的元素，还必须添加内边距，边框和外边距。 当然我们也可以添加一个属性设置整个盒子的总宽度和高度 /* 加上这个css3的新特性，可以自动计算，保持总的宽高是设置的值 */ box-sizing: border-box; 负值的margin带来的影响 一般来说，我们都是给一个元素设置margin正值来调整与其他元素的距离，如果我们给margin设置负值会发生什么呢？ 我们分两种情况讨论： 水平方向 1、margin-left设置负值，会使自身以及后面的元素一起往左移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的宽度content的百分比) 2、margin-right设置负值，自身不发生改变，但会令后面的元素往左移动，移动的距离原理同上。 垂直方向 1、margin-top设置负值，会使自身以及后面的元素一起往上移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的高度content的百分比) 2、margin-bottom设置负值，自身不发生改变，但会令后面的元素往上移动，移动的距离原理同上。 ————————-可以在下方CSS指定位置中测试 See the Pen 负值的margin带来的影响 by liaozhijie8 (@liaozhijie8) on CodePen. CSS Float(浮动) 在网页流中，所有元素都是一个盒子，类似于玩俄罗斯方块一样，如果一行宽度不够放下一个完整的积木，那么这块积木将会放到下一行，慢慢地充满整个网页。这是一个二维的平面，如果转变为三维模型，把每一个元素再加上一个厚度。假设在排列过程中每一块元素的厚度一致，一行排不下同样需要换行，但是有些元素我们还是希望他们在这一行排列，那么就把他们排列在第二层中，这就是CSS float特性，具体参考标题链接。 CSS Position(定位) 有时候我们希望元素能按照给定的坐标定位，例如坐标(x,y),那么我们只需设置一个参考的原点即可，那就是position属性，详情点击链接。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:1","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"双飞翼布局 原理 双飞翼布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。 双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间middle多了一个子容器存在，通过控制 middle 的子容器的 margin或者padding空出左右两列的宽度。 See the Pen 双飞布局 by liaozhijie8 (@liaozhijie8) on CodePen. 1、左中右三列都设置float左浮动 2、中间列设置100%的宽度(达到自适应剩余宽度的效果)，并包含一个子元素(用于显示内容)，设置子元素的左右padding或者margin(防止显示内容被左右两列覆盖) 3、左右列设置固定的宽度 4、浮动的元素与浮动的元素同样会受盒子模型的影响而正常元素一样排列，这个时候，我们给浮动的元素设置margin负值调整具体的位置 5、左列元素我们希望它移动到最左边，设置margin-left:100%，这个100%是相对父元素的，因为它与中间列同属一个父元素，所以刚好移动到最左边 6、右列元素因为设置了浮动，并没有紧挨着左列元素，而是遇到中间列的元素边框排在了其身后，设置margin-left：自身宽度，使他排列在最右边 具体设置可以修改上图参数观看变化过程 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:2","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"圣杯布局 圣杯布局与双飞翼布局的不同点在于，左中右三列包含在同一个父元素下，中间列设置padding或者margin留出位置给左右两列 左列元素尽管设置了margin-left:-100%,仍然无法移动到最右边，因为它与中间列同属一个父元素，所以需要利用position属性往左移动自身宽度 右列元素有两种方法设置，1)设置margin-right:-自身宽度，其元素后面的元素会往前移动 2)设置position:相对定位，margin-left：-自身宽度，right:-自身宽度; See the Pen 圣杯布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:3","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["JavaScript"],"content":"浅谈一下变量关键字","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":" ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:0","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"var、let、const的几点区别 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:1","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"1、重复声明 let和const都不允许，var可以。为了规范编程减少使用var，其实在vueAPI中也大多数情况下用const去初始化数据，主要是要获得响应式的数据，我们都不会直接去重新赋值 \u003c!-- 基本数据类型 --\u003e const name = 'tom' name = 'jack' //error \u003c!-- 引用数据类型 --\u003e const person = { name:'tom', age:22 } person = { name:'leon', age:33 } //error //采用另一种修改方式 person.name = 'leon' //成功修改 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:2","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"2、变量提升： var会提升变量声明到当前作用域的前面 function test() { var i = 22 } console.log(i) //22 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:3","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"3、暂时性死区 只要作用域内存在let、const，他们所声明的变量或常量就会自动绑定这个区域，不再受外部作用域的影响 function test() { let i = 22 } console.log(i) //error ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:4","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"4、window对象的属性和方法 全局作用域下，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法 var age = 18 console.log(window.age) ==18 function add(){ console.log('你好') } window.add === add //全等 但是使用const\\let声明的变量或function都不会变为window中的 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:5","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"5、作用域链 function func(){ for(let i = 0; i \u003c 4;i ++){ console.log(i) } } //当函数被调用即产生了一个函数作用域 func() // 1 console.log(i) //error i 未定义 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:6","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 一些块级作用域 {} //花括号以及带有{}的一些方法 for(let){} // 需要和const let 配合 while(){} if(){} // 等等 function fuc(){} //函数作用域 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:7","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"应用 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:8","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"绑定事件案例 \u003cbutton\u003e按钮1\u003c/button\u003e \u003cbutton\u003e按钮2\u003c/button\u003e \u003cbutton\u003e按钮3\u003c/button\u003e \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } 当我们点击分别点击按钮时，期望得到的时相应的i，即0，1，2(实际全是2)。但是由于绑定事件属于{块级作用域}，而var定义的i是具有函数级作用域的，所有在每一个绑定事件的{块级作用域}中是找不到i的值，故会出到外层查找，外层循环结束后i的值为2。 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:9","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法一 在ES6之前我们可以用闭包的办法解决 \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { //创建一个即时函数 (function(index){ btn[i].addEventListener('click',function(){ console.log(index) }) })(i) } ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:10","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:11","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法二 ES6以后，我们采用let 或 const 锁定作用域范围，达到和上面采用闭包一样的效果 \u003c!-- 绑定点击事件 --\u003e let btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(let i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } //0 1 2 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:12","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:13","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"}]