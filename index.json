[{"categories":["性能优化"],"content":" 前端性能优化 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:0","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"纵观http请求的过程，可以得出一些请求过程中的潜在的性能优化 dns是否可以通过缓存减少dns查询的时间? 网络请求的过程走最近的网络环境？ 相同的静态资源是否可以缓存？ 能否减少请求http请求大小？ 减少http请求 服务端渲染 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:1","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"资源的合并与压缩 减少http请求的数量 减少请求资源的大小 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:2","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"html 压缩 webpack打包压缩 nodejs 提供了html-minifier工具 后端模板引擎渲染压缩 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:3","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"css 压缩 clean-css库 无效代码删除 css语义合并-有些属性重复 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:4","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"js 压缩与混乱 —uglifyjs2 无效字符的删除 剔除注释 代码语义的缩减和优化 代码保护-降低代码的可读性 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:5","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"文件合并 存在的问题:1、首屏渲染问题 2、缓存失效问题 公共库合并 不同页面的合并 开启gzip ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:6","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"图片优化 一、不同格式图片常用的业务场景 jpg有损压缩，压缩率高，不支持透明——应用与大部分不需要透明图片的业务场景 png支持透明，浏览器兼容性好——应用于大部分需要透明图片的业务场景 webp压缩程度更好，在ios webview有兼容性问题——安卓 svg矢量图，拉伸不失真，代码内嵌,相对较小,图片样式相对简单的场景——图片样式相对简单的业务场景，icon,logo 二、图片压缩——针对真实图片情况，舍弃一些相对无关紧要的色彩信息 CSS精灵图 把网站上用到的一些图片整合到一张单独的图片中(减少网站的HTTP请求数量)，利用CSS背景属性进行调整，需要控制精灵图的大小，过大可能会导致加载过慢，整个页面内容显示不正常。 Image inline 将图片的内容内嵌到html当中,减少网站HTTP请求数量 使用矢量图 使用SVG进行矢量图的绘制 使用iconfont解决icon问题 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:7","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"HTML渲染过程 一、需要考虑的点 顺序执行、并发执行 词法分析 并发加载 并发上限 是否阻塞 1)CSS阻塞 css head中阻塞页面的渲染 css阻塞js的执行 css不阻塞外部脚本的加载，外部的脚本是基于已经加载完的css样式去操作dom 2)js阻塞 直接引入(srcipt src=‘js’)会导致阻塞页面的渲染 js不阻塞资源的加载，会预先扫描，预加载 js顺序执行，会阻塞后续js逻辑的执行(单线程) 依赖关系 1)页面渲染依赖于css的加载 2)js的执行顺序的依赖关系 3)js逻辑对于dom节点的依赖关系 js引入方式 直接引入 defer引入 async 异步动态引入js 二、加载和执行的一些优化点 css样式表置顶 用link 代替 import js 脚本置底 合理使用js的异步加载能力 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:8","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"懒加载与预加载 一、懒加载 图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景使用 减少无效资源的加载 并发加载的资源过多会阻塞js的加载，影响网站的正常使用 二、预加载 图片等静态资源在使用之前的提前请求 资源使用到时能从缓存中加载，提升用户体验 页面展示的依赖关系维护 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:9","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"重绘与回流 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢 解决办法： 1)寻找替代会引起重绘回流的方案(避免使用触发重绘，回流的CSS属性) 2)如无法避免，将频繁重绘回流的DOM元素单独作为一个独立图层，一次插入到布局中，那么这个dom元素的重绘回流只会影响一次，而且在独立图层里 一、回流 当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建——回流 当页面布局和几何属性改变时就需要回流 1)触发的条件 盒子模型相关属性——width、height、padding、margin、display、border 定位属性及浮动——top、bottom、left、right、position、float、clear 改变节点内部文字结构—— text-align overflow-y font-weight overflow font-family line-height vertical-align white-space font-size、 二、重绘 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color——重绘 三、新建DOM的过程 获取DOM后分割为多个图层 对每个图层的节点计算样式结果(Recalculate style 样式重计算) 为每个节点生成图形和位置(Layout 回流和重布局) 将每个节点绘制填充到图层位图中(Paint Setup和Paint 重绘) 图层作为纹理上传至gpu 符合多个图层到页面上生成最终屏幕图像(Composite Layers 图层重组) 四、浏览器绘制DOM的过程是这样子的： 获取 DOM 并将其分割为多个层（layer），将每个层独立地绘制进位图（bitmap）中 将层作为纹理（texture）上传至 GPU，复合（composite）多个层来生成最终的屏幕图像 left/top/margin之类的属性会影响到元素在文档中的布局，当对布局（layout）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。 transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。 通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。 五、chrome创建图层的条件 ——将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中 3D或透视变换 CSS属性使用加速视频解码的 video 元素 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 canvas 元素 复合插件(如 Flash) 进行 opacity/transform 动画的元素拥有加速 CSS filters 的元素元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里) 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染) 总结：对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧 六、优化点总结 用translate替代top属性 top会触发layout，但translate不会 用opacity代替visibility opacity不会触发重绘也不会触发回流，只是改变图层alpha值，但是必须要将这个图片独立出一个图层 visibility会触发重绘 不要一条一条的修改DOM的样式，预先定义好class，然后修改DOM的className 把DOM离线后修改，比如：先把DOM给display:none（有一次reflow），然后你修改100次，然后再把它显示出来 不要把DOM节点的属性值放在一个循环里当成循环的变量 offsetHeight、offsetWidth每次都要刷新缓冲区，缓冲机制被破坏 先用变量存储下来 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局，div只会影响后续样式的布局 动画实现的速度的选择，选择合适的动画速度 根据performance量化性能优化 对于动画新建图层 启用gpu硬件加速(并行运算)，gpu加速意味着数据需要从cpu走总线到gpu传输，需要考虑传输损耗. transform:translateZ(0) transform:translate3D(0) ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:10","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"浏览器存储 一、cookie 用于浏览器端和服务器端的交互(主要作用，维护用户状态) 客户端自身数据的存储(在localstorage诞生前的主要手段) cookie中在相关域名下面导致cdn的流量损耗——解决方案：cdn的域名和主站域名要分开 二、LocalStorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 三、SessionStorage 会话级别的浏览器存储(和localstorage唯一的区别) 场景： 对于表单信息的维护 四、indexedDB IndexedDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然WebStorage对于存储叫少量的数据很管用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 场景：为应用创建离线版本 五、PWA PWA(Progressive Web Apps)是一种Web App新模型，并不是具体指某一种前言的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强Web App的用户体验 检测是不是一个渐进式 web app 1)当前手机在弱网环境下能不能加载出来 2)离线环境下能不能加载出来 特点 1)可靠：没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面 2)快速：针对网页渲染及网络数据访问有较好的优化 3)融入(Engaging)：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性 六、service worker 是一个脚本，浏览器独立于当前页面，将其在后台运行，为实现一些不依赖页面的或者用户交互的特性打开了一扇大门。在未来这些特性将包括消息推送，背景后台同步， geofencing(地理围栏定位)，但他将推出的第一个首要的特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:11","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["性能优化"],"content":"浏览器缓存 ","date":"2022-11-24","objectID":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:12","tags":["实践"],"title":"前端性能优化","uri":"/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["前端工程化"],"content":" 前端工程化概念 前端工程化解决了什么问题 js全局作用域冲突 编码规范问题 资源合并和压缩问题 高版本js预发降级 ","date":"2022-11-05","objectID":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/:0:0","tags":["概念"],"title":"前端工程化","uri":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"categories":["项目全流程"],"content":"git:分布式管理 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:0:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"一、基础概念 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"三个区域 工作区→暂存区→git仓库 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:1","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"三个状态 以修改、以暂存、已更新 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:2","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"安装配置 image.png ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:3","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"创建仓库 一、将现有目录初始化为仓库 1、在项目目录中，打开git Bash，输入git init 2、查下文件状态 git status 或者 git status -s 3、添加到暂存区 “git add .“或者 git add 指定名称 4、提交更新git commit -m “提交提示信息” 二、修改文件后提交流程 如果已经添加到更新的文件发生了修改，可以用git status -s 查看 然后再次执行git add .提交更新到暂存区，利用git commit -m 提交更新 三、撤销对文件的修改 注意：此时的文件并没有提交到更新仓库，撤销将是不可逆的，一般很少用的 四、移除暂存区中的文件 git reset HEAD + 指定文件名称 或者.移除全部文件出暂存区 五、直接提交到仓库 git commit -a -m “描述消息” 六、移除文件 1、工作区（本地）和仓库的文件都一起移除（不可逆） git rm -f “文件名” 2、仓库文件移除，只保留工作区 git rm –cached “文件名” 七、忽略文件 参考vue脚手架自带文件 八、查看提交历史 git log -2 表示查看最近俩条 回退版本 git reset –hard +对应的commit号 回到回退前的版本号 先查看所有操作日记，包括已经回退了的 git reflog git reset –hard 回退到指定版本 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:1:4","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"二、远程仓库操作 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:0","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"1、绑定 HTTPS ：不需要配置但是每次访问都需要输入github账号密码。 1）、绑定仓库 git remote add origin https://github.com/liaozhijie8/vue3.0_project_zhihu.git git branch -M main git push -u origin main 2）、后续的提交 利用git push 将本地commit的内容提交到远程仓库 SSH ：需要进行额外的配置，之后每次访问都不需要账号密码 1）、获取key http://t.zoukankan.com/emily1130-p-7503546.html 2)、按照提示配置仓库 git push ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:1","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["项目全流程"],"content":"2、分支 1）、创建分支 git branch 分支名称 →git checkout 分支名称 切换分支 git checkout -b 分支名称 —–新建一个分支并切换到改分支下 2）、合并分支 1、先切换到上一级分支 git checkout 分支名 2、合并分支 git merge 分支名 3）、删除分支 先回到上一层分支中，然后再用git branch -d 下一层分支名称删除分支 4）、分支冲突 打开冲突文件，手动解决冲突 5）、将分支推送到远程仓库 6）、跟踪远程仓库 参考GitHub 7）、拉取远程仓库 git pull 8）、删除远程仓库的分支 git push origin –delete 分支名称 ","date":"2022-08-05","objectID":"/git%E5%9F%BA%E7%A1%80/:2:2","tags":["版本管理","团队协助"],"title":"Git基础","uri":"/git%E5%9F%BA%E7%A1%80/"},{"categories":["JavaScript"],"content":"随便记录一下","date":"2022-07-26","objectID":"/javascript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0/","tags":["笔记"],"title":"JavaScript红宝书笔记","uri":"/javascript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Vue"],"content":"vue各版本的API别 ","date":"2022-07-18","objectID":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/:0:0","tags":["API","vue"],"title":"Vue不同版本API","uri":"/vue%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACapi/"},{"categories":["Vue"],"content":"Vuex is a state management pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":" State Management Pattern ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"为什么需要状态管理？ 在回答这个问题之前我们先看一下不用Vuex,是如何进行组件之间的数据传递的 以Vue2为例子，组件之间的数据共享大致分为三部分 类型 方式 父组件-\u003e子组件 子组件中,通过 props 来自定义属性 父组件中,负责把数据，通过 v-bind: 绑定给子组件 子组件-\u003e父组件 子组件中调用 this.$emit() 来触发自定义事件. 父组件中，通过 v-on: 来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件传递过来的数据。. 兄弟组件共享数据 EventBus 其实原理与子组件传父组件相似 显然这种方式对于单个数据或者少量数据处理是没有问题的，但是官方提出了两个问题 Multiple views may depend on the same piece of state. Actions from different views may need to mutate the same piece of state. 当我们需要多组件共享数据或者处理数据时，会变得繁琐，尤其是当嵌套组件过多时，单向数据的传递会变得尤为复杂且低效 为解决这两个问题,需要一个全局管理数据的工具—–Vuex Vuex工作流程 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:1","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"如何使用Vuex 组成部分 组成 作用 State 存放全局数据 Getters 简单计算处理State中的数据,再传递给组件 Mutations 通过commit方法改变State中的数据,执行的是同步操作 Actions 通过dispatch方法调用Mutations中的方法改变State中的数据,执行的是异步操作 Modules 模块化 ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:2","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"使用步骤 利用createStore方法新建实例 import { createStore } from 'vuex' import index from './cart/index' const store = createStore({ modules: { cart: index //子模块 } }) export default store 在main函数中注册 import { createApp } from 'vue' import App from './App.vue' import store from './store' //引入注册 const app = createApp(App) app.use(store) app.mount('#app') 子模块定义数据方法 import { Goods } from './interface' export default { // 开启空间命名 namespaced: true, state: { goods: [ { id: 0, name: '牙刷', price: 20, count: 22 }, { id: 1, name: '平板', price: 2, count: 322 }, { id: 2, name: '背包', price: 210, count: 266 }, { id: 3, name: '电脑', price: 203, count: 255 }, { id: 4, name: '手机', price: 204, count: 23 } ], totalPrice: 0 }, getters: { getPrice: (state: Goods) =\u003e (price: number) =\u003e { return state.goods.filter(d =\u003e d.price \u003e price) } }, mutations: { addPrice(state: Goods, id: number) { state.totalPrice += state.goods[id].price } }, actions: { fetchTotalPrice({ commit }, payload: number) { commit('addPrice', payload) } } } 在组件中使用 需要注意引用子模块的方式 import { useStore } from 'vuex' setup() { const store = useStore() // 引用方法store.属性.模块名称.数据 const goods = computed(() =\u003e store.state.cart.goods) const totalPrice = computed(() =\u003e store.state.cart.totalPrice) const chooseGoods = (id: number) =\u003e { // 使用action store.dispatch('cart/fetchTotalPrice', id) } // // // 使用getter const priceGoods = computed(() =\u003e store.getters['cart/getPrice'](100)) return { goods, priceGoods, totalPrice, chooseGoods } } }) ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:3","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["Vue"],"content":"全新的版本pinia Why should I use Pinia? ","date":"2022-07-18","objectID":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:4","tags":["vue","数据管理"],"title":"Vue的状态管理","uri":"/vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"关于 王者荣耀全能烹饪师 ","date":"2022-07-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["书签整理"],"content":"学习书签集合","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["书签整理"],"content":" JavaScript学习书签 各种对象方法 JavaScript 中 call()、apply()、bind() 的用法 ES6 教程 CSS学习书签 Flex 布局语法教程 CSS灵感 ","date":"2021-07-09","objectID":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/:0:0","tags":["学习书签"],"title":"书签页","uri":"/javascript%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"},{"categories":["CSS"],"content":"一次解决所有居中烦恼","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"水平居中 根据元素的类型不同可以分为两类情况 一类使行内元素，它不能设置宽高，所以需要给其父元素设置一个text-align: center; 一类使块级元素，其可以设置宽高， 在自身已经设置宽高具体参数的情况下，可以给margin：0 auto 利用position属性，相对父元素，移动左边或右边50%，然后再设置margin调整位置 See the Pen 各种水平居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:1","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"垂直居中 See the Pen 垂直居中 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-06-02","objectID":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/:0:2","tags":["布局","居中"],"title":"各种居中","uri":"/%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD/"},{"categories":["CSS"],"content":"flex就是好用","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":" Flex 布局语法教程 ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:0","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"flex实现双飞布局 父元素设置flex，项目元素设置比例即可实现布局 See the Pen flex布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:1","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"画颗骰子 设置项目元素自身属性align-self调节垂直方向位置 See the Pen flex布局骰子 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-22","objectID":"/flex%E5%B8%83%E5%B1%80/:0:2","tags":["Flex布局","布局"],"title":"Flex布局","uri":"/flex%E5%B8%83%E5%B1%80/"},{"categories":["CSS"],"content":"float布局页面","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":" 经典的双飞翼与圣杯布局，主要利用了CSS盒子模型的特性，以float布局为主要方法，结合Position属性。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:0","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"前置知识了解 CSS盒子模型 我们需要先了解CSS的盒子模型，详细的参考标题链接内容，关键点在于当我们指定一个CSS元素的宽度和高度属性时，只是设置内容区域的宽度和高度，要知道，完整大小的元素，还必须添加内边距，边框和外边距。 当然我们也可以添加一个属性设置整个盒子的总宽度和高度 /* 加上这个css3的新特性，可以自动计算，保持总的宽高是设置的值 */ box-sizing: border-box; 负值的margin带来的影响 一般来说，我们都是给一个元素设置margin正值来调整与其他元素的距离，如果我们给margin设置负值会发生什么呢？ 我们分两种情况讨论： 水平方向 1、margin-left设置负值，会使自身以及后面的元素一起往左移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的宽度content的百分比) 2、margin-right设置负值，自身不发生改变，但会令后面的元素往左移动，移动的距离原理同上。 垂直方向 1、margin-top设置负值，会使自身以及后面的元素一起往上移动，移动的距离可以给具体值，也可以设置百分比(相对父元素的高度content的百分比) 2、margin-bottom设置负值，自身不发生改变，但会令后面的元素往上移动，移动的距离原理同上。 ————————-可以在下方CSS指定位置中测试 See the Pen 负值的margin带来的影响 by liaozhijie8 (@liaozhijie8) on CodePen. CSS Float(浮动) 在网页流中，所有元素都是一个盒子，类似于玩俄罗斯方块一样，如果一行宽度不够放下一个完整的积木，那么这块积木将会放到下一行，慢慢地充满整个网页。这是一个二维的平面，如果转变为三维模型，把每一个元素再加上一个厚度。假设在排列过程中每一块元素的厚度一致，一行排不下同样需要换行，但是有些元素我们还是希望他们在这一行排列，那么就把他们排列在第二层中，这就是CSS float特性，具体参考标题链接。 CSS Position(定位) 有时候我们希望元素能按照给定的坐标定位，例如坐标(x,y),那么我们只需设置一个参考的原点即可，那就是position属性，详情点击链接。 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:1","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"双飞翼布局 原理 双飞翼布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。 双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间middle多了一个子容器存在，通过控制 middle 的子容器的 margin或者padding空出左右两列的宽度。 See the Pen 双飞布局 by liaozhijie8 (@liaozhijie8) on CodePen. 1、左中右三列都设置float左浮动 2、中间列设置100%的宽度(达到自适应剩余宽度的效果)，并包含一个子元素(用于显示内容)，设置子元素的左右padding或者margin(防止显示内容被左右两列覆盖) 3、左右列设置固定的宽度 4、浮动的元素与浮动的元素同样会受盒子模型的影响而正常元素一样排列，这个时候，我们给浮动的元素设置margin负值调整具体的位置 5、左列元素我们希望它移动到最左边，设置margin-left:100%，这个100%是相对父元素的，因为它与中间列同属一个父元素，所以刚好移动到最左边 6、右列元素因为设置了浮动，并没有紧挨着左列元素，而是遇到中间列的元素边框排在了其身后，设置margin-left：自身宽度，使他排列在最右边 具体设置可以修改上图参数观看变化过程 ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:2","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["CSS"],"content":"圣杯布局 圣杯布局与双飞翼布局的不同点在于，左中右三列包含在同一个父元素下，中间列设置padding或者margin留出位置给左右两列 左列元素尽管设置了margin-left:-100%,仍然无法移动到最右边，因为它与中间列同属一个父元素，所以需要利用position属性往左移动自身宽度 右列元素有两种方法设置，1)设置margin-right:-自身宽度，其元素后面的元素会往前移动 2)设置position:相对定位，margin-left：-自身宽度，right:-自身宽度; See the Pen 圣杯布局 by liaozhijie8 (@liaozhijie8) on CodePen. ","date":"2021-05-21","objectID":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/:0:3","tags":["布局","float布局"],"title":"双飞与圣杯布局本质","uri":"/%E5%8F%8C%E9%A3%9E%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%9C%AC%E8%B4%A8/"},{"categories":["JavaScript"],"content":"浅谈一下变量关键字","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":" ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:0","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"var、let、const的几点区别 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:1","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"1、重复声明 let和const都不允许，var可以。为了规范编程减少使用var，其实在vueAPI中也大多数情况下用const去初始化数据，主要是要获得响应式的数据，我们都不会直接去重新赋值 \u003c!-- 基本数据类型 --\u003e const name = 'tom' name = 'jack' //error \u003c!-- 引用数据类型 --\u003e const person = { name:'tom', age:22 } person = { name:'leon', age:33 } //error //采用另一种修改方式 person.name = 'leon' //成功修改 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:2","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"2、变量提升： var会提升变量声明到当前作用域的前面 function test() { var i = 22 } console.log(i) //22 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:3","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"3、暂时性死区 只要作用域内存在let、const，他们所声明的变量或常量就会自动绑定这个区域，不再受外部作用域的影响 function test() { let i = 22 } console.log(i) //error ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:4","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"4、window对象的属性和方法 全局作用域下，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法 var age = 18 console.log(window.age) ==18 function add(){ console.log('你好') } window.add === add //全等 但是使用const\\let声明的变量或function都不会变为window中的 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:5","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"5、作用域链 function func(){ for(let i = 0; i \u003c 4;i ++){ console.log(i) } } //当函数被调用即产生了一个函数作用域 func() // 1 console.log(i) //error i 未定义 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:6","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 一些块级作用域 {} //花括号以及带有{}的一些方法 for(let){} // 需要和const let 配合 while(){} if(){} // 等等 function fuc(){} //函数作用域 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:7","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"应用 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:8","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"绑定事件案例 \u003cbutton\u003e按钮1\u003c/button\u003e \u003cbutton\u003e按钮2\u003c/button\u003e \u003cbutton\u003e按钮3\u003c/button\u003e \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } 当我们点击分别点击按钮时，期望得到的时相应的i，即0，1，2(实际全是2)。但是由于绑定事件属于{块级作用域}，而var定义的i是具有函数级作用域的，所有在每一个绑定事件的{块级作用域}中是找不到i的值，故会出到外层查找，外层循环结束后i的值为2。 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:9","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法一 在ES6之前我们可以用闭包的办法解决 \u003c!-- 绑定点击事件 --\u003e var btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(var i = 0;i \u003c btn.length;i ++) { //创建一个即时函数 (function(index){ btn[i].addEventListener('click',function(){ console.log(index) }) })(i) } ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:10","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:11","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"解决方法二 ES6以后，我们采用let 或 const 锁定作用域范围，达到和上面采用闭包一样的效果 \u003c!-- 绑定点击事件 --\u003e let btn = document.querSelectorAll('button') //给每一个按钮绑定点击事件 for(let i = 0;i \u003c btn.length;i ++) { btn[i].addEventListener('click',function(){ console.log(i) }) } //0 1 2 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:12","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"},{"categories":["JavaScript"],"content":"原理图 ","date":"2021-05-19","objectID":"/es6%E5%8F%98%E9%87%8F/:0:13","tags":["ES6新特性","变量"],"title":"ES6新关键字","uri":"/es6%E5%8F%98%E9%87%8F/"}]